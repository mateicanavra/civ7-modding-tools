**Title**  
V0.1 Slice 2: Browser-test adds first tile-space output (height/landmask) + streams 2 grid layers to deck.gl

**Status**  
Complete (implemented: browser-test streams `foundation.crustTiles.baseElevation` + `foundation.crustTiles.type` grid layers to deck.gl via VizSink).

**Context**  
We have a working V0.1 “pure browser pipeline” foundation:
- MapGen Studio can run the `browser-test` recipe (currently Foundation-only) inside a Web Worker.
- The Worker streams visualization payloads in-memory to the main thread (VizSink), and MapGen Studio renders them via deck.gl (no dump required).
- Config overrides are editable via a schema-driven UI and applied deterministically (UI → protocol → Worker merge onto base config).

This slice extends that end-to-end path from “Foundation artifacts + overlay-ish layers” to the first stable **tile-space grid** outputs that later stages (Hydrology/Morphology/Placement) will build on.

**Goal**  
From MapGen Studio, click “Run (Browser)” → Worker runs `browser-test` Foundation end-to-end → produces the first meaningful per-tile fields:
- `crustTiles.baseElevation` (continuous scalar field; units TBD but deterministic)
- `crustTiles.type` (categorical land/ocean classification)

Worker streams these as **two grid layers** through VizSink, and the UI renders them directly in deck.gl using the shared tile-grid contract (row-major indexing + stable tile layout).

**What this slice is meant to resolve / answer**  
- Can we bridge from Foundation’s internal artifacts into a tile-space grid output that will later align with Civ’s terrain/elevation expectations?
- Do our Worker→VizSink message shapes + transferables hold up for “real” grid payloads (not just point/segment overlays)?
- Do we have the right coordinate conventions (tile layout) and palette/legend handling for the next stages that are fundamentally grid-based?

**What confidence it gives us**  
- Proves the core “pipeline → tile fields → in-memory visualization” path that Hydrology/Morphology/Placement will build on.
- Establishes the first stable “tile grid layer contract” we can keep extending (more fields, more stages).

**How it prepares for the rest of the pipeline**  
Hydrology and later stages depend on stable per-tile fields (elevation/land-water/terrain classifications). This slice creates that foundation in the `browser-test` recipe so subsequent slices can focus on adding stages and adapter coverage, not re-plumbing outputs.

**Non-goals**  
- Perfect 1:1 Civ7 engine elevation/terrain passes
- Terrain type assignment, biomes, rivers, resources, starts (these belong to later slices)
- Runtime “drop-in” recipe loading without rebuild
- Full “standard” recipe execution in the browser

**Deliverables**  
- A “tile grid layer contract” for VizSink that can represent:
  - width/height (tile dimensions)
  - a deterministic tile index order / coordinate mapping
  - a typed payload for `crustTiles.baseElevation` (recommended: `Float32Array`)
  - a typed payload for `crustTiles.type` (recommended: `Uint8Array`)
- Worker implementation that produces `crustTiles.baseElevation` + `crustTiles.type` deterministically from Foundation outputs and streams them as `layer.upsert` events.
- UI implementation that renders:
  - `crustTiles.baseElevation` as a continuous or binned raster-style visualization in tile-space
  - `crustTiles.type` as a categorical overlay (e.g., land vs water)
- Palette/legend defaults sufficient to interpret the two layers (minimal but not confusing), using optional layer metadata when available.

**Acceptance criteria**  
- With the same seed + config, `crustTiles.baseElevation` and `crustTiles.type` grid payloads are byte-identical across runs (within the browser).
- Worker streams the two grid layers without blocking the UI and without exceeding reasonable message sizes (use transferables for typed arrays).
- UI renders both layers via deck.gl and allows selecting between them (or toggling visibility) without requiring any dump/export.
- The layer contract is documented in-code (types + comments) and used consistently by Worker and UI.

**Implementation notes / checklist**  
- Decide the exact “tile coordinate system” for the grid contract:
  - define tile index order and mapping to deck.gl positions (and keep it stable).
- Extract `crustTiles.baseElevation`/`crustTiles.type` from Foundation artifacts.
- VizSink payload design:
  - prefer a single message per layer with transferables for arrays.
  - include min/max stats for `height` to drive palettes without scanning on the main thread.
- Visualization:
  - keep it simple: a heatmap/raster-like layer for `crustTiles.baseElevation`, categorical coloring for `crustTiles.type`.
  - ensure the deck.gl layer uses the same tile mapping as the Worker.

**Risks / unknowns**  
- Tile coordinate conventions: getting the mapping wrong now causes churn later; this slice exists to lock it early.
- Payload size vs map size presets: ensure we don’t accidentally stream huge intermediate artifacts (stream only the final per-tile arrays for these two layers).
- Palette/legend: keep minimal but stable; avoid over-investing before we have more stages.

**Follow-up (post-slice)**  
- Add additional tile fields as later slices require (moisture/temperature/flow, etc.).
- Revisit the “tile grid contract” if we later introduce streaming deltas/chunks for performance (not required for this slice).
