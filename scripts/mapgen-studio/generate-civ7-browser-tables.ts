import { mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, resolve } from "node:path";

type ExtractedTables = {
  terrainTypeOrder: string[];
  biomeOrder: string[];
  featureOrder: string[];
};

function fatal(message: string): never {
  console.error(message);
  process.exit(1);
}

function extractXmlSection(xml: string, tag: string): string {
  const re = new RegExp(`<${tag}[^>]*>([\\s\\S]*?)<\\/${tag}>`, "m");
  const m = re.exec(xml);
  if (!m?.[1]) fatal(`[civ7-tables] missing <${tag}> section`);
  return m[1];
}

function extractRowAttr(sectionXml: string, attr: string): string[] {
  const out: string[] = [];
  const re = new RegExp(`<Row\\s+[^>]*${attr}="([^"]+)"[^>]*/>`, "g");
  let m: RegExpExecArray | null;
  while ((m = re.exec(sectionXml))) {
    const v = m[1];
    if (v) out.push(v);
  }
  return out;
}

function assertNoDuplicates(label: string, values: string[]): void {
  const seen = new Set<string>();
  const dupes = new Set<string>();
  for (const v of values) {
    if (seen.has(v)) dupes.add(v);
    seen.add(v);
  }
  if (dupes.size) fatal(`[civ7-tables] duplicate ${label}: ${[...dupes].join(", ")}`);
}

function indexByOrder(values: string[]): Record<string, number> {
  return Object.fromEntries(values.map((v, i) => [v, i]));
}

function parseTerrainXml(xml: string): ExtractedTables {
  const terrains = extractRowAttr(extractXmlSection(xml, "Terrains"), "TerrainType");
  const biomes = extractRowAttr(extractXmlSection(xml, "Biomes"), "BiomeType");
  const features = extractRowAttr(extractXmlSection(xml, "Features"), "FeatureType");

  if (!terrains.length) fatal("[civ7-tables] no terrain rows found");
  if (!biomes.length) fatal("[civ7-tables] no biome rows found");
  if (!features.length) fatal("[civ7-tables] no feature rows found");

  assertNoDuplicates("terrain types", terrains);
  assertNoDuplicates("biomes", biomes);
  assertNoDuplicates("features", features);

  return {
    terrainTypeOrder: terrains,
    biomeOrder: biomes,
    featureOrder: features,
  };
}

function toTsObjectLiteral(obj: Record<string, number>): string {
  const lines = Object.keys(obj)
    .sort()
    .map((k) => `  ${JSON.stringify(k)}: ${obj[k]},`);
  return `{\n${lines.join("\n")}\n}`;
}

function main(): void {
  const repoRoot = process.cwd();
  const terrainXmlPath = resolve(
    repoRoot,
    ".civ7/outputs/resources/Base/modules/base-standard/data/terrain.xml"
  );
  const outPath = resolve(repoRoot, "apps/mapgen-studio/src/civ7-data/civ7-tables.gen.ts");

  const xml = readFileSync(terrainXmlPath, "utf8");
  const extracted = parseTerrainXml(xml);

  const terrainTypeIndices = indexByOrder(extracted.terrainTypeOrder);
  const biomeGlobals = indexByOrder(extracted.biomeOrder);
  const featureTypes = indexByOrder(extracted.featureOrder);

  mkdirSync(dirname(outPath), { recursive: true });

  const relSource = "Base/modules/base-standard/data/terrain.xml";
  const file = `/* eslint-disable */
/**
 * GENERATED FILE â€” DO NOT EDIT BY HAND.
 *
 * Generated by: \`bun scripts/mapgen-studio/generate-civ7-browser-tables.ts\`
 * Source of truth: \`${relSource}\` (under \`.civ7/outputs/resources\`)
 *
 * Purpose:
 * - Provide Civ7-derived indices (terrain/biome/feature) as a bundled, browser-importable module.
 * - The Web Worker must not fetch these at runtime.
 */

export const CIV7_BROWSER_TABLES_V0 = {
  version: 0 as const,
  source: ${JSON.stringify(relSource)} as const,
  terrainTypeIndices: ${toTsObjectLiteral(terrainTypeIndices)} as const,
  biomeGlobals: ${toTsObjectLiteral(biomeGlobals)} as const,
  featureTypes: ${toTsObjectLiteral(featureTypes)} as const,
} as const;

export type Civ7BrowserTablesV0 = typeof CIV7_BROWSER_TABLES_V0;
`;

  writeFileSync(outPath, file);
  console.log(`[civ7-tables] wrote ${outPath}`);
}

main();

